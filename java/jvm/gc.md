# GC

## 对象回收条件

### 如何判断对象可以回收
* 引用计数法 Reference Counting
    * 策略
        * 给对象一个引用计数器，引用计数为0时可以回收
    * 优点
        * 实现简单
        * 判定效率高
    * 缺点
        * 难以解决对象循环引用问题
        * 并且开销较大，频繁且大量的引用变化，带来大量的额外运算
    *  主流的JVM都没有选用引用计数算法来管理内存
* 可达性分析算法 Reachability Analysis
    * 策略
        * 通过GC Roots的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为引用链（Reference Chain），当一个对象从GC Roots不可达时，则可以回收
    * 优点
        * 更加精确和严谨，可以分析出循环数据结构相互引用的情况
    * 缺点
        * 实现比较复杂
        * 需要分析大量数据，消耗大量时间
        * 分析过程需要GC停顿（引用关系不能发生变化），即停顿所有Java执行线程

### 关于引用
* 强引用 Strong Reference
    * 引用最常见的对象，如new出来的对象
    * 有强引用则永远不会被GC
* 软引用 Soft Reference
    * 有用但非必须的对象
    * 如果将发生内存溢出时，会回收这些对象
* 弱引用 Weak Reference
    * 非必须的对象
    * 在下一次发生GC的时候回收这些对象
* 虚引用 Phantom Reference
    * 又称幽灵引用或幻影引用，Phantom就是幻影的意思，是最弱的一种引用
    * 虚引用的目的是能在这个对象被回收的时候收到一个系统通知

![对象回收条件](https://ws2.sinaimg.cn/large/006tNbRwly1fwwaemhwwhj31kw0rtk2u.jpg)

## 垃圾收集算法

### 算法原理
* 标记清除算法 Mark-Sweep
    * 策略
        * 首先标记需要回收的对象，在标记完成后统一回收
    * 优点
        * 基础算法，思路简单，后续的GC算法都是基于该算法改进的
    * 缺点
        * 效率低
        * 会产生内存碎片
* 复制收集算法 Copying
    * 策略
        * 将可用内存分为两半，每次只使用其中一半。当一半用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存一次性清理掉
    * 优点
        * 解决了标记清除算法的效率问题，实现简单，运行高效
    * 缺点
        * 空间浪费较大，内存利用效率仅为50%
    * 适用场景
        * 回收新生代
        * 一般是将新生代的内存分为1个Eden空间和2个Survivor空间，比例为8:1:1
        * 每次都是用Eden空间和一个Survivor空间
        * 回收时将Eden空间和一个Survivor空间还存活的对象复制到另一个Survivor空间上，这样内存利用效率就为90%
        * 问题
            * 出现极端情况时，存活的对象数量大于10%，即超过了Survivor空间大小，需要依赖老年代进行分配担保
* 标记整理算法 Mark-Compact
    * 策略
        * 标记完成后，移动存活的对象到内存一段，形成连续内存，而后直接清理掉边界以外的内存
    * 使用场景
        * 回收老年代
* 分代收集算法 Generational Collection
    * 策略
        * 将内存分代，分为新生代和老年代，新生代里的对象存活率很低，老年代的对象存活率较高。
        * 新生代
            * 复制收集算法
        * 老年代
            * 标记清除或标记整理算法

### 算法实现
* 枚举根节点
    * 枚举根节点也就是查找GC Roots，用于可达性分析
    * 枚举根节点会引起所有Java执行线程的停顿
* GC Roots
    * 一组必须活跃的引用
    * 举例
        * 所有Java线程当前活跃栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值
        * VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用
        * JNI handles，包括global handles和local handles
        * （看情况）所有当前被加载的Java类
        * （看情况）Java类的引用类型静态变量
        * （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）
        * （看情况）String常量池（StringTable）里的引用

![垃圾收集算法](https://ws3.sinaimg.cn/large/006tNbRwly1fwwaevqfqaj31kw1fc7ps.jpg)

## 垃圾收集器

### 基本概念
* 并行
    * Parallel
        * 多条垃圾收集线程并行工作，但用户线程还是等待状态
* 并发
    * Concurrent
        * 用户线程与垃圾收集线程同时执行（可能是交替执行）

### Serial 收集器
* 特性
    *  单线程回收
    * 简单高效（与其他收集器的单线程比）
    * 独占式回收，会导致STW（Stop The World）
* 作用域
    * Client模式下默认的新生代收集器
* 算法
    * Copying

### Serial Old 收集器
* 特性
    * 同Serial
* 作用域
    * Client模式下老年代，可以与多种新生代回收期配合使用，也可作为CMS的备用回收器
* 算法
    * Mark-Compact

### ParNew 收集器
* Serial收集器的多线程版本
* 特性
    * Serial 收集器的多线程版本
* 作用域
    * 新生代
* 算法
    * Copying

### Parallel Scavenge 收集器
* 特性
    * 吞吐量优先
    * 最小化STW的时间
* 作用域
    * 新生代
* 算法
    * Copying

### Parallel Old 收集器
* 特性
    * 吞吐量优先
    * 最小化STW的时间
* 作用域
    * 老年代
* 算法
    * Mark-Compact

### CMS（Concurrent Mark Sweep）收集器
* 特性
    * 大部分时间并发（Mostly-Concurrent）
    * 并发低延迟，以最短回收停顿为目标
    * CBU资源敏感，吞吐量较低
    * 无法处理浮动垃圾
    * 会产生空间碎片
* 作用域
    * 老年代
* 算法
    * Mark-Sweep
        * 初始标记(STW initial mark)
        * 并发标记(Concurrent mark)
        * 重新标记(STW remark)
        * 并发清理(Concurrent sweep)

### G1（Garbage First）收集器
* 特性
    * 并行性
        * 多个GC线程同时工作
    * 并发性
        * 应用程序交替执行，不会在整个回收阶段阻塞
    * 分代GC
        * 分代回收且兼顾年轻代和老年代
    * 空间整理
        * 回收过程中，会进行适当的对象移动，少空间碎片
    * 可预见性
        * 可预存停顿的模型，选择适当的区域进行收集，确保停顿时间不超过用户指定时间
* 作用域
    * 兼顾年轻代和老年代
* 算法
    * 初始标记
        * 标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短
    * 并发标记
        * 从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行
    * 最终标记
        * 为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log 里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行
    * 筛选回收
        * 对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收

![垃圾收集器](https://ws3.sinaimg.cn/large/006tNbRwly1fwwaf8k23jj31kw2q61kx.jpg)

## 内存分配与回收策略

* 对象优先在Eden区分配

* 大对象直接进入老年代

### 长期存活的对象将进入老年代
* 对象年龄（Age）
    * 对象经历过的YoungGC并存活，年龄+1
* 年龄到15岁（默认值）会被移入老年代

### 动态对象年龄判定
* Survivor区相同年龄所有对象大小总和大于Survivor空间的一半，则大于该年龄的对象自动移入老年代

### 空间分配担保
* YoungGC需要老年代空间做担保，如果担保空间不足，会根据历史平均晋升到老年代的大小判断是否尝试进行一次YoungGC或直接FullGC。担保空间不足也会引发另一次FullGC。

![内存分配与回收策略](https://ws4.sinaimg.cn/large/006tNbRwly1fwwafsumrpj31kw0pa7a9.jpg)