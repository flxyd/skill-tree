# 原生同步
## 同步代码块
* synchronized
  * 偏向锁
* wait
* notify
* notifyAll
## 其他线程方法
* join
* yield
* sleep
## volatie
* 在多处理器开发中保证了共享变量的可见性
## 原生锁优化（JDK6以后）
### 锁升级
* JDK 1.6后，引入了锁的升级和粗化，锁一共有4种状态，界别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态
### 偏向锁
* 一个线程访问同步块时，会使这个同步块的偏向锁指向该线程，之后再次进入和退出同步块时，不需要进行CAS来加锁和解锁，只需要简单的检测一下同步块的偏向锁是否指向该线程即可。偏向锁使用了延迟解锁的机制，及等到竞争出现才释放锁。
* 优点
    * 加锁解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距
* 缺点
    * 如果线程间存在竞争，会带来额外的锁撤销的消耗
* 适用场景
    * 一个线程多次使用一个同步块
### 轻量级锁
* 如果偏向锁竞争失败，则使用CAS获取同步块的轻量级锁，如果同步块执行结束时，会还原对象头，如果成功，则表示没有竞争。如果失败，锁就会膨胀成重量级锁。
* 优点
    * 竞争的线程不会阻塞，提高了程序的相应速度
* 缺点
    * 如果始终得不到锁竞争的线程，处于自旋状态会消耗CPU
* 适用场景：多个线程交替使用一个同步块
* 为什么要使用CAS
    * 使用CAS尝试将对象的Mark Word更新为指向Lock Record的指针
* 为什么要使用自旋
    * 使用自旋是在发生竞争时，竞争的线程会将锁膨胀为重量级锁，并通过自旋来获取该锁
### 重量级锁
* 当竞争轻量级锁失败时，会尝试获取对象的重量级锁，重量级锁的竞争会引发线程阻塞
* 优点
    * 线程竞争不使用自旋，不会消耗CPU
* 缺点
    * 线程阻塞，相应时间会变慢
* 适用场景
    * 多个线程同时使用一个同步块
### 自旋锁与自适应自旋
略
## Skill Tree
![native](https://ws4.sinaimg.cn/large/006tNc79gy1fvrocloj48j31kw1c5nbx.jpg)
