# 锁理论
## 自旋锁
### 简单自旋锁
* 简单循环检查是否可以获取锁
* 缺点
    * CAS操作需要硬件的配合
    * 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重
    * 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁
### Ticket Lock
* 原理
    * 好比服务窗口排队，每个人领一个号，然后不停的问窗口，是不是到我了，到了就执行，没到就继续问
* 优点
    * 解决了简单自旋锁的公平性问题
* 缺点
    * 多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能
### CLH Lock
* 原理
    * 好比服务窗口排队，每个人只关心排在自己前面的人，不断问前面的人搞定没有，搞定了就轮到自己了，没搞定就继续等着
* 优点
    * 空间复杂度低
* 缺点
    * NUMA系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣
### MCS Lock
* 原理
    * 好比服务窗口排队，每个人只关心自己就好，一直等着前面的人搞定了来通知到你了，没人来通知的话就一直等着
* 优点
    * 解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题
* 缺点
    * 空间复杂度高，实现复杂
## 偏向锁
* 见原生同步
## CAS导致Cache一致性流量
略
## 可重入锁
* 支持一个线程对资源重复的加锁而不会被自己阻塞
* 实现原理
  * 辨识请求锁的线程是否为当前持有锁的线程，如果是则计数加1。释放锁的时候计数器减1，减到0的时候释放锁
## 锁消除（Lock Elimination）
* 锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁
## 锁粗化（Lock Coarsening）
* 将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁
## 适应性自旋（Adaptive Spinning）
* 为了避免自旋消耗过多的CPU，一般会设置自旋的次数限制。JDK中使用了自适应自旋，就是如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少
## 公平锁和非公平锁
* 公平锁
  * 在绝对时间上，先对锁进行获取的请求一定先被满足，则是公平锁。也就是先请求先获取
* 非公平锁
  * 反之是不公平的
* 公平锁往往没有非公平锁效率高，但是公平锁能减少“饥饿”发生
## Skill Tree
![lock](https://ws1.sinaimg.cn/large/006tNc79gy1fvrm4akpfxj31kw0puka6.jpg)