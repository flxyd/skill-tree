# 结构型模式-Structural Pattern

## 目录
> 1. [适配器模式-Adapter Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter-pattern)
> 2. [桥接模式-Bridge Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-bridge-pattern)
> 3. [组合模式-Composite Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-composite-pattern)
> 4. [装饰模式-Decorator Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-decorator-pattern)
> 5. [外观模式/门面模式-Facade Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F-facade-pattern)
> 6. [享元模式-Flyweight Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-flyweight-pattern)
> 7. [代理模式-Proxy Pattern](https://github.com/flxyd/skill-tree/blob/master/designPattern/StructuralPattern.md#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-proxy-pattern)

---
##  适配器模式-Adapter Pattern
### 使用频率
★★★★☆
### 目标问题
对于两个无法修改的结构或系统，需要一种方式将两个结构适配在一起。如同220V的插座和20V的电脑，需要一个电源适配器
### 解决方案
将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)
##### 两种类型的适配器
- 对象适配器
  - 适配器与适配者之间是关联关系，使用频率更高
- 类适配器
  - 适配器与适配者之间是继承（或实现）关系
##### 主要角色
- Target（目标抽象类）
- Adapter（适配器类）
- Adaptee（适配者类）
### 变体
##### 缺省适配器模式
当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况
Java.awt.event中广泛使用了缺省适配器模式
### 优缺点
- ##### 优点
  - 将目标类和适配者类解耦
  - 增加了类的透明性和复用性
  - 灵活性和扩展性都非常好
- ##### 缺点
  - java不支持多继承，所以不能同时适配多个适配者
  - 适配者类不能为final类
  - 类适配器模式中的目标抽象类只能为接口，不能为类
### 适用场景
系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要
想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类
### Skill Tree
![适配器模式 Adapter Pattern](https://ws1.sinaimg.cn/large/006tNbRwgy1fv7z6dqejtj31kw0jitnc.jpg)

---
##  桥接模式-Bridge Pattern
### 使用频率
★★★☆☆
### 目标问题
如果软件系统中某个类存在两个独立变化的维度，如何将这两个维度分离出来，使两者可以独立扩展
### 解决方案
将抽象部分与它的实现部分分离，使它们都可以独立地变化。
又称为柄体(Handle and Body)模式或接口(Interface)模式
 桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛
### 优缺点
- ##### 优点
  - 在很多情况下，桥接模式可以取代多层继承方案
  - 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”
  - 桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，分离了抽象接口及其实现部分
- ##### 缺点
  - 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性
### 适用场景
如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系
“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响
一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展
对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用
### Skill Tree
![桥接模式 Bridge Pattern](https://ws3.sinaimg.cn/large/006tNbRwgy1fv7z6nmk8dj31kw0hetpn.jpg)

---
##  组合模式-Composite Pattern
### 使用频率
★★★★☆
### 目标问题
对于树形结构的对象，如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子
### 解决方案
组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。
组合模式又可以称为“整体—部分”(Part-Whole)模式
组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理
##### 主要角色
- Component（抽象构件）
  - 它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法。
- Leaf（叶子构件）
- Composite（容器构件）
### 优缺点
- ##### 优点
  - 清楚地定义分层次的复杂对象，表示对象的全部或部分层次
  - 客户端可以一致地使用一个组合结构或其中单个对象
  - 在组合模式中增加新的容器构件和叶子构件都很方便
- ##### 缺点
  - 在增加新构件时很难对容器中的构件类型进行限制
### 适用场景
在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异
分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型
### Skill Tree
![组合模式 Composite Pattern](https://ws2.sinaimg.cn/large/006tNbRwgy1fv7z75d6soj31kw0sl171.jpg)

---
##  装饰模式-Decorator Pattern
### 使用频率
★★★☆☆
### 目标问题
在不改变一个对象本身功能的基础上给对象增加额外的新行为
### 解决方案
动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。
##### 主要角色
- Component（抽象构件）
  - 声明了在具体构件中实现的业务方法，可以使客户端进行一致化处理
- ConcreteComponent（具体构件）
- Decorator（抽象装饰类）
  - 用于给具体构件增加职责，维护一个指向抽象构件对象的引用
- ConcreteDecorator（具体装饰类）
### 优缺点
- ##### 优点
  - 对于扩展一个对象的功能，装饰模式比继承更加灵活性
  - 动态的方式来扩展一个对象的功能
  - 可以对一个对象进行多次装饰
  - 具体构件类与具体装饰类可以独立变化
- ##### 缺点
  - 会产生很多小对象
### 适用场景
在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式
### Skill Tree
![装饰模式 Decorator Pattern](https://ws1.sinaimg.cn/large/006tNbRwgy1fv7z7ez58fj31kw0jdqs2.jpg)

---
##  外观模式/门面模式-Facade Pattern
### 使用频率
★★★★★
### 目标问题
客户端与多个子系统有复杂交互，是的客户端使用非常复杂，难以维护，希望能将客户端与这些系统之间交互的复杂性降低
### 解决方案
为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
##### 主要角色
- Facade（外观角色）
- SubSystem（子系统角色）
### 优缺点
- ##### 优点
  - 对客户端屏蔽了子系统组件
  - 子系统与客户端之间的松耦合关系
  - 子系统的修改对其他子系统没有任何影响
- ##### 缺点
  - 不能很好地限制客户端直接使用子系统类
  - 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则
### 适用场景
要为访问一系列复杂的子系统提供一个简单入口
客户端程序与多个子系统之间存在很大的依赖性
在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系
### Skill Tree
![门面模式 Facade Pattern](https://ws4.sinaimg.cn/large/006tNbRwgy1fv7z7jpe2bj31kw0qajzv.jpg)

---
##  享元模式-Flyweight Pattern
### 使用频率
★☆☆☆☆
### 目标问题
解决软件系统在运行时产生的对象数量太多，将导致运行代价过高，带来系统性能下降等问题
### 解决方案
享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。
- 内部状态
  - 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。
- 外部状态
  - 外部状态是随环境改变而改变的、不可以共享的状态。
运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式
##### 主要角色
- Flyweight（抽象享元类）
- ConcreteFlyweight（具体享元类）
  - 在具体享元类中为内部状态提供了存储空间。
  - 通常我们可以结合单例模式来设计具体享元类
- UnsharedConcreteFlyweight（非共享具体享元类）
- FlyweightFactory（享元工厂类）
  - 将各种类型的具体享元对象存储在一个享元池中
### 优缺点
- ##### 优点
  - 可以极大减少内存中对象的数量
  - 享元模式的外部状态相对独立
- ##### 缺点
  - 元模式使得系统变得复杂
  - 享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长
### 适用场景
一个系统有大量相同或者相似的对象，造成内存的大量耗费
对象的大部分状态都可以外部化，可以将这些外部状态传入对象中
### Skill Tree
![享元模式 Flyweight Pattern](https://ws4.sinaimg.cn/large/006tNbRwgy1fv7z7rski1j31kw0h44qp.jpg)

---
##  代理模式-Proxy Pattern
### 使用频率
★★★★☆
### 目标问题
无法直接访问某个对象或访问某个对象存在困难，需要通过一个代理对象来间接访问
### 解决方案
给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问
##### 主要角色
- Subject（抽象主题角色）
  - 声明了真实主题和代理主题的共同接口，任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程
- Proxy（代理主题角色）
  - 包含了对真实主题的引用，可以在任何时候操作真实主题对象；通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作。
- RealSubject（真实主题角色）
  - 代理角色所代表的真实对象
### 变体
- 远程代理(Remote Proxy)
  - 为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)
- 虚拟代理(Virtual Proxy)
  - 如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建
- 保护代理(Protect Proxy)
  - 控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限
- 缓冲代理(Cache Proxy)
  - 为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果
- 智能引用代理(Smart Reference Proxy)
  - 当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等
### 优缺点
- ##### 优点
  - 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
  - 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则
- ##### 缺点
  - 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂
  - 有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理
### 适用场景
当客户端对象需要访问远程主机中的对象时可以使用远程代理。
当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。
当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。
当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。
当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。
### Skill Tree
![代理模式 Proxy Pattern](https://ws1.sinaimg.cn/large/006tNbRwgy1fv7z80d4oij31kw0m3tv2.jpg)
